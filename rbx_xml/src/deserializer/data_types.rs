mod bitfields;
mod cframe;
mod colors;
mod font;
mod physical_properties;
mod ray;
mod rect;
mod sequences;
mod simple_types;
mod udims;
mod unique_id;
mod vectors;

use std::io::BufRead;

use rbx_dom_weak::types::Variant;

pub use self::{
    bitfields::{axes_deserializer, faces_deserializer},
    cframe::cframe_deserializer,
    colors::{color3_deserializer, color3uint8_deserializer},
    font::font_deserializer,
    physical_properties::physical_properties_deserializer,
    ray::ray_deserializer,
    rect::rect_deserializer,
    sequences::{
        color_sequence_deserializer, number_range_deserializer, number_sequence_deserializer,
    },
    simple_types::{
        binary_string_deserializer, bool_deserializer, content_deserializer, enum_deserializer,
        f32_deserializer, f64_deserializer, i32_deserializer, i64_deserializer,
        string_deserializer,
    },
    udims::{udim2_deserializer, udim_deserializer},
    unique_id::unique_id_deserializer,
    vectors::{vector2_deserializer, vector3_deserializer, vector3int16_deserializer},
};

use super::{
    error::{DecodeError, ErrorKind},
    XmlReader,
};

/// Generates two public functions.
///
/// The first, `attempt_deserialization`, attempts to deserialize an element
/// from the given `element_name`.
///
/// The second, `is_known_type`, returns whether a given element name is known
/// to map to a type we can deserialize.
///
/// An example invocation looks like this:
/// ```ignore
/// deserializers! {
///     "Element Name" => Variant::DataType; use deserialize_type,
///     "Name 2" | "Another Name" => Variant::DataType2; use deserialize_other_type,
/// }
/// ```
macro_rules! deserializers {
    ($($elem_base:literal $(| $elem:literal) * => $variant:path; use $deserializer:path),*$(,)?) => {
        /// Attempts to deserialize a value based on `element_name`.
        /// If the element is known to correspond to a data type, it reads it
        /// and returns it as a `Variant`. If the type is not known or it can't
        /// be read, it will return a `DecodeError` instead.
        ///
        /// Note that this function is generated by a macro and may return an
        /// unexpected variant. See the implementation for more details.
        pub fn attempt_deserialization<R: BufRead>(reader: &mut XmlReader<R>, element_name: &str) -> Result<Variant, DecodeError> {
            match element_name {
                $($elem_base $(| $elem) * => Ok($variant($deserializer(reader)?)),)*
                _ => Err(ErrorKind::UnknownType(element_name.into()).err()),
            }
        }

        /// Returns whether a particular `element_name` is known to be
        /// associated with a data type that can be deserialized.
        ///
        /// When this function returns `true`, that element *can* be
        /// deserialized. It may still fail for various reasons.
        pub fn is_known_type(element_name: &str) -> bool {
            match element_name {
                $($elem_base $(| $elem) * => true,)*
                _ => false,
            }
        }
    };
}

deserializers! {
    // We handle Ref and SharedString in the main deserializer, but they still
    // need to be read somehow so we deserialize them as strings.
    "Ref" | "SharedString" => Variant::String; use string_deserializer,

    "string" | "ProtectedString" => Variant::String; use string_deserializer,
    "int" => Variant::Int32; use i32_deserializer,
    "int64" => Variant::Int64; use i64_deserializer,
    "float" => Variant::Float32; use f32_deserializer,
    "double" => Variant::Float64; use f64_deserializer,
    "bool" => Variant::Bool; use bool_deserializer,
    "BinaryString" => Variant::BinaryString; use binary_string_deserializer,
    "Vector3" => Variant::Vector3; use vector3_deserializer,
    "Vector2" => Variant::Vector2; use vector2_deserializer,
    "Vector3int16" => Variant::Vector3int16; use vector3int16_deserializer,
    "Ray" => Variant::Ray; use ray_deserializer,
    "token" => Variant::Enum; use enum_deserializer,
    "CoordinateFrame" => Variant::CFrame; use cframe_deserializer,
    "Color3" => Variant::Color3; use color3_deserializer,
    "Color3uint8" => Variant::Color3uint8; use color3uint8_deserializer,
    "Faces" => Variant::Faces; use faces_deserializer,
    "Axes" => Variant::Axes; use axes_deserializer,
    "NumberSequence" => Variant::NumberSequence; use number_sequence_deserializer,
    "ColorSequence" => Variant::ColorSequence; use color_sequence_deserializer,
    "NumberRange" => Variant::NumberRange; use number_range_deserializer,
    "UDim" => Variant::UDim; use udim_deserializer,
    "UDim2" => Variant::UDim2; use udim2_deserializer,
    "Font" => Variant::Font; use font_deserializer,
    "Rect2D" => Variant::Rect; use rect_deserializer,
    "PhysicalProperties" => Variant::PhysicalProperties; use physical_properties_deserializer,
    "Content" => Variant::Content; use content_deserializer,
    "UniqueId" => Variant::UniqueId; use unique_id_deserializer,
}
