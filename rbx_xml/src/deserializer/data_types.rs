mod bitfields;
mod cframe;
mod colors;
// mod faces;
// mod font;
// mod number_range;
// mod number_sequence;
mod ray;
// mod rect;
mod simple_types;
// mod udims;
// mod unique_id;
mod vectors;

use std::io::BufRead;

use rbx_dom_weak::types::Variant;

pub use simple_types::{
    binary_string_deserializer, bool_deserializer, enum_deserializer, f32_deserializer,
    f64_deserializer, i32_deserializer, i64_deserializer, string_deserializer,
};

pub use cframe::cframe_deserializer;
pub use colors::{color3_deserializer, color3uint8_deserializer};
pub use ray::ray_deserializer;
pub use vectors::{vector2_deserializer, vector3_deserializer, vector3int16_deserializer};

use self::bitfields::{axes_deserializer, faces_deserializer};

use super::{
    error::{DecodeError, ErrorKind},
    XmlReader,
};

/// Generates two public functions.
///
/// The first, `attempt_deserialization`, attempts to deserialize an element
/// from the given `element_name`.
///
/// The second, `is_known_type`, returns whether a given element name is known
/// to map to a type we can deserialize.
///
/// An example invocation looks like this:
/// ```ignore
/// deserializers! {
///     "Element Name" => Variant::DataType; use deserialize_type,
///     "Name 2" | "Another Name" => Variant::DataType2; use deserialize_other_type,
/// }
/// ```
macro_rules! deserializers {
    ($($elem_base:literal $(| $elem:literal) * => $variant:path; use $deserializer:path),*$(,)?) => {
        /// Attempts to deserialize a value based on `element_name`.
        /// If the element is known to correspond to a data type, it reads it
        /// and returns it as a `Variant`. If the type is not known or it can't
        /// be read, it will return a `DecodeError` instead.
        ///
        /// Note that this function is generated by a macro and may return an
        /// unexpected variant. See the implementation for more details.
        pub fn attempt_deserialization<R: BufRead>(reader: &mut XmlReader<R>, element_name: &str) -> Result<Variant, DecodeError> {
            match element_name {
                $($elem_base $(| $elem) * => Ok($variant($deserializer(reader)?)),)*
                _ => Err(ErrorKind::UnknownType(element_name.into()).err()),
            }
        }

        /// Returns whether a particular `element_name` is known to be
        /// associated with a data type that can be deserialized.
        ///
        /// When this function returns `true`, that element *can* be
        /// deserialized. It may still fail for various reasons.
        pub fn is_known_type(element_name: &str) -> bool {
            match element_name {
                $($elem_base $(| $elem) * => true,)*
                _ => false,
            }
        }
    };
}

deserializers! {
    // We handle Ref and SharedString in the main deserializer, but they still
    // need to be read somehow so we deserialize them as strings.
    "Ref" | "SharedString" => Variant::String; use string_deserializer,

    "string" | "ProtectedString" => Variant::String; use string_deserializer,
    "int" => Variant::Int32; use i32_deserializer,
    "int64" => Variant::Int64; use i64_deserializer,
    "float" => Variant::Float32; use f32_deserializer,
    "double" => Variant::Float64; use f64_deserializer,
    "bool" => Variant::Bool; use bool_deserializer,
    "BinaryString" => Variant::BinaryString; use binary_string_deserializer,
    "Vector3" => Variant::Vector3; use vector3_deserializer,
    "Vector2" => Variant::Vector2; use vector2_deserializer,
    "Vector3int16" => Variant::Vector3int16; use vector3int16_deserializer,
    "Ray" => Variant::Ray; use ray_deserializer,
    "token" => Variant::Enum; use enum_deserializer,
    "CoordinateFrame" => Variant::CFrame; use cframe_deserializer,
    "Color3" => Variant::Color3; use color3_deserializer,
    "Color3uint8" => Variant::Color3uint8; use color3uint8_deserializer,
    "Faces" => Variant::Faces; use faces_deserializer,
    "Axes" => Variant::Axes; use axes_deserializer,
}
