mod ray;
mod simple_types;
mod vectors;

use std::io::BufRead;

use rbx_dom_weak::types::Variant;

pub use simple_types::{
    binary_string_deserializer, bool_deserializer, f32_deserializer, f64_deserializer,
    i32_deserializer, i64_deserializer, string_deserializer,
};

pub use ray::ray_deserializer;
pub use vectors::vector3_deserializer;

use super::{
    error::{DecodeError, ErrorKind},
    XmlReader,
};

/// Generates two public functions.
///
/// The first, `attempt_deserialization`, attempts to deserialize an element
/// from the given `element_name`.
///
/// The second, `is_known_type`, returns whether a given element name is known
/// to map to a type we can deserialize.
///
/// An example invocation looks like this:
/// ```ignore
/// deserializers! {
///     "Element Name" => Variant::DataType; use deserialize_type,
///     "Name 2" | "Another Name" => Variant::DataType2; use deserialize_other_type,
/// }
/// ```
macro_rules! deserializers {
    ($($elem_base:literal $(| $elem:literal) * => $variant:path; use $deserializer:path),*$(,)?) => {
        /// Attempts to deserialize a value based on `element_name`.
        /// If the element is known to correspond to a data type, it reads it
        /// and returns it as a `Variant`. If the type is not known or it can't
        /// be read, it will return a `DecodeError` instead.
        ///
        /// Note that this function is generated by a macro and may return an
        /// unexpected variant. See the implementation for more details.
        pub fn attempt_deserialization<R: BufRead>(reader: &mut XmlReader<R>, element_name: &str) -> Result<Variant, DecodeError> {
            match element_name {
                $($elem_base $(| $elem) * => Ok($variant($deserializer(reader)?)),)*
                _ => Err(ErrorKind::UnknownType(element_name.into()).err()),
            }
        }

        /// Returns whether a particular `element_name` is known to be
        /// associated with a data type that can be deserialized.
        ///
        /// When this function returns `true`, that element *can* be
        /// deserialized. It may still fail for various reasons.
        pub fn is_known_type(element_name: &str) -> bool {
            match element_name {
                $($elem_base $(| $elem) * => true,)*
                _ => false,
            }
        }
    };
}

deserializers! {
    // We handle Ref and SharedString in the main deserializer, but they still
    // need to be read somehow so we deserialize them as strings.
    "Ref" | "SharedString" => Variant::String; use string_deserializer,

    "string" | "ProtectedString" => Variant::String; use string_deserializer,
    "int" => Variant::Int32; use i32_deserializer,
    "int64" => Variant::Int64; use i64_deserializer,
    "float" => Variant::Float32; use f32_deserializer,
    "double" => Variant::Float64; use f64_deserializer,
    "bool" => Variant::Bool; use bool_deserializer,
    "BinaryString" => Variant::BinaryString; use binary_string_deserializer,
    "Vector3" => Variant::Vector3; use vector3_deserializer,
    "Ray" => Variant::Ray; use ray_deserializer,
}
